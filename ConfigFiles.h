#include<Afxmt.h>
class ConfigFiles
{
private:
	
	static ConfigFiles *m_pConfigFiles;
	CMutex  m_LogMutex;
	
	CFile	m_hLogFile;
	CString m_sLogFileName;
	
	CFile	m_hListFile;
	CString m_sListFileName;
	
	CString m_sBaseURL;
	CString m_sAppDir;

	CString m_sProjectName;

	TCHAR lpBuffer[255];
	
	
	ConfigFiles():m_sLogFileName("fweb-cache\\log.txt"),m_sListFileName("fweb-cache\\list.txt")		
	{
		
	}
	
	
public:
	static ConfigFiles* MakeObject()
	{
		if(m_pConfigFiles == NULL)
		{
			m_pConfigFiles = new ConfigFiles;
			return m_pConfigFiles;
		}
		else 
			return m_pConfigFiles;
	}
	static void RemoveObject()
	{
		if(m_pConfigFiles != NULL)
			delete m_pConfigFiles;

		m_pConfigFiles = NULL;
		
	}
	void UpdateLog(CString& url,CString& status)
	{
		
		CSingleLock downloadSingleLock(&m_LogMutex);
		downloadSingleLock.Lock();
		
		CString str = url + " : " + status + "\r\n";
		
		
		if( m_hLogFile.Open(m_sLogFileName,CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite   ) )
		{
			m_hLogFile.SeekToEnd();
			TRY
			{
				m_hLogFile.Write(str,str.GetLength());
			}
			CATCH(CFileException, e);  
			{
				e->Delete();
			}
			END_CATCH
				m_hLogFile.Close();
			
		}
	}
	void UpdateList(vector<CString>& List)
	{
		if (m_hListFile.Open(m_sListFileName,CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite ))
		{
			
			vector<CString>::iterator _iter;
			for(_iter = List.begin();_iter!=List.end();_iter++)
			{
				(*_iter)+="\r\n";
				TRY
				{
					m_hListFile.Write((*_iter),(*_iter).GetLength());
				}
				CATCH(CFileException, e);  
				{
					e->Delete();
				}
				END_CATCH
			}
			m_hListFile.Close();
		}
	}
	BOOL RemoveHashQMark(CString& URL)
	{
		
		DWORD p = URL.Find('#');
		if(p==0)	// URL contains only # part #Somewhere
			return FALSE;
		else if(p==-1)
		{
			DWORD q = URL.Find('?');
			if(q != -1)
			{
				URL = URL.Left(q);
			}
			return TRUE;
		}
		else
			URL = URL.Left(p);
		DWORD q = URL.Find('?');
		if(q != -1)
		{
			URL = URL.Left(q);
		}
		return TRUE;
		
	}
	CString GetExtension(CString& URL)
	{
		RemoveHashQMark(URL);	
		INT nDot;  
		INT nSlash; 
		
		nDot= URL.ReverseFind('.');
		if(nDot == -1)
			return "";
		nSlash= URL.ReverseFind('/');
		if(nDot < nSlash)
			return "";
		else
		{
			CString ext = URL.Right(URL.GetLength() - nDot-1);
			return ext;
		}
	}	
	void MakeIndex(CString sBaseURL)
	{
		DWORD dwServiceType=0;
		CString strServer;
		CString strObject;
		INTERNET_PORT nPort;
		if(!AfxParseURL(sBaseURL,dwServiceType,strServer,strObject,nPort ) )
		{
			//Try sticking "http://" before it
			sBaseURL = _T("http://") + sBaseURL;
			AfxParseURL(sBaseURL,dwServiceType,strServer,strObject,nPort );
		}
		
		CString ext =GetExtension(strObject);
		if(ext.IsEmpty() == TRUE)
		{
			
			if( (strObject.GetAt(strObject.GetLength() - 1) != '/' ) || (strObject.GetAt(strObject.GetLength() - 1) != '/' ) )
				strObject = strServer+strObject + "/index.html"; 
			
			else
				strObject =strServer +strObject + "index.html";
		}
		else
		{
			strObject = strServer+strObject ; 			
		}
		MakeMetaIndex(strObject);
		
		CString empty;
		CString sIndex = empty + "<HTML>\n\n\n <!-- Mirror and index made by FetchWeb Website Copier-->\n\n\n"+
			"<HEAD>\n <TITLE> Local index </TITLE>\n </HEAD>\n <BODY BACKGROUND=\"backblue.gif\">"+
			"\n<H1 ALIGN=Center>\n<U>Index of locally available sites:</U>\n 	</H1> <BR><BR>"+
			"<TABLE BORDER=\"0\" WIDTH=\"100%\" CELLSPACING=\"1\" CELLPADDING=\"0\"> <UL> 	<TR> " +
			"<TD BACKGROUND=\"fade.gif\"> <LI> 	<A HREF=\"" +strObject+  "\">" + strObject + "</A><BR></LI></TD></TR>"+
			"</TABLE></UL><BR><BR> 	<BR>	</BODY>	<I><H6 ALIGN=\"RIGHT\">\n\n\nMirror and index made by" + 
			"FetchWeb Website Copier</H6></I>\n\n\n 	<!-- Thanks for using Fetch Web Website Copier! -->\n\n\n" +
			"\n</HTML> ";
		
		CFile	hIndexFile;
		CString sIndexName = m_sBaseURL + "index.html";
		if (hIndexFile.Open(sIndexName,CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite ))
		{	
			
			
			TRY
			{
				hIndexFile.Write(sIndex,sIndex.GetLength());
			}
			CATCH(CFileException, e);  
			{
				e->Delete();
			}
			END_CATCH
				
			hIndexFile.Close();
		}

			
	}
	void MakeMetaIndex(CString URL)
	{
		CFile	hMetaIndex;
		CString sMetaIndexContent;
		if(URL.IsEmpty() == FALSE)
			if(URL.GetAt(0) != '\\' || URL.GetAt(0) != '/')
			{}//URL = m_sAppDir + "\\" + URL;
			else
				URL =URL.Right(URL.GetLength() -1);// m_sAppDir + URL;

		CString sFileName = m_sAppDir + "\\" + "MySites\\index.html";
		if(GetFileAttributes(sFileName) == 0xFFFFFFFF) 
		{// Make New Index
			CString empty;
			sMetaIndexContent = empty + "<!-- Generated by FetchWeb Website Copier -->"+
				"\n<HTML>"+
				"\n<HEAD>"+
				"\n<TITLE>List of available projects</TITLE>"+
				"\n</HEAD>"+
				"\n<BODY>"+
				"\n<H1 ALIGN=Center><U>Index of locally available projects:</U>"+
				"\n<BR><BR>"+
				"\n<TABLE BORDER=\"0\" WIDTH=\"100%\" CELLSPACING=\"1\" CELLPADDING=\"0\">"+
				"\n" + MakeMetaEntry(URL) +
				"\n</TABLE>"+
				"\n</BODY>"+
				"\n</HTML>";

			if (hMetaIndex.Open(sFileName,CFile::modeCreate | CFile::modeWrite ))
			{			
				
				TRY
				{
					hMetaIndex.Write(sMetaIndexContent,sMetaIndexContent.GetLength());
				}
				CATCH(CFileException, e);  
				{
					e->Delete();
				}
				END_CATCH
					
					hMetaIndex.Close();
			}
		}
		else
		{			
			if (hMetaIndex.Open(sFileName,CFile::modeNoTruncate | CFile::modeReadWrite   ))
			{
				char* p = new char[hMetaIndex.GetLength()] ;
				
				TRY
				{
					hMetaIndex.Read(p,hMetaIndex.GetLength());
				}
				CATCH(CFileException, e);  
				{
					e->Delete();
				}
				
				END_CATCH
				p[hMetaIndex.GetLength()] = '\0';
				
				sMetaIndexContent = p;
				INT dwLeft = sMetaIndexContent.Find('<');
				CString sTag = sMetaIndexContent.Mid(dwLeft,6);
				
				while (sTag.CompareNoCase("/TABLE") != 0)
				{
					dwLeft = sMetaIndexContent.Find('<',dwLeft+1);
					sTag = sMetaIndexContent.Mid(dwLeft+1,6);
				}
				hMetaIndex.SetLength(0);

				TRY
				{
					hMetaIndex.Write(sMetaIndexContent.Left(dwLeft),dwLeft);
					CString t = MakeEntry(URL);
					hMetaIndex.Write(t,t.GetLength());
					hMetaIndex.Write(sMetaIndexContent.Right(sMetaIndexContent.GetLength() - dwLeft),sMetaIndexContent.GetLength() - dwLeft);				
				}
				CATCH(CFileException, e);  
				{
					e->Delete();
				}
				END_CATCH

				hMetaIndex.Close();
			}
		}

	}

	CString MakeEntry(CString& URL)
	{
		CString empty;
		// Extracts the file name from the URL
		CString iFile;
		iFile = URL.Right(URL.GetLength() - URL.ReverseFind('/')-1);
		CString sOutPut = empty + "<UL>"+
						"\n<TR>"+
						"\n<TD>"+
						"\n<LI>"+
						"\n<tt><a href=\""+ m_sProjectName + "\\" +iFile+"\">"+ m_sProjectName + "</a></tt>"+
						"\n</LI>"+
						"\n</TD>"+
						"\n</TR>"+
						"\n</UL>";
		return sOutPut;
			
	}
	CString MakeMetaEntry(CString& URL)
	{
		CString empty;
		// Extracts the file name from the URL
		CString iFile;
		iFile = "index.html";
		CString sOutPut = empty + "<UL>"+
						"\n<TR>"+
						"\n<TD>"+
						"\n<LI>"+
						"\n<tt><a href=\""+ m_sProjectName + "\\" +iFile+"\">"+ m_sProjectName + "</a></tt>"+
						"\n</LI>"+
						"\n</TD>"+
						"\n</TR>"+
						"\n</UL>";
		return sOutPut;
			
	}
	
	BOOL CreateAllDirectories(CString strDir)
	{
		if(strDir.GetLength() == 0)
			return FALSE;
		CString currentDir;
		INT     currentPos=0;
		
		strDir.Replace('\\','/');
		
		while(strDir[0] == '/' )
		{
			strDir = strDir.Right(strDir.GetLength( )-1 );  
		}
		
		while(currentPos != -1)
		{
			currentPos = strDir.Find( '/',currentPos );  
			if(currentPos == -1)
				break;
			
			currentDir=strDir.Left(currentPos);
			
			if(GetFileAttributes(currentDir) == FILE_ATTRIBUTE_DIRECTORY) 
			{
				currentDir += "/" ;
				currentPos++;
				continue;
			}
			
			if ( CreateDirectory(currentDir,NULL) == 0)
				return FALSE;
			
			currentDir += "/" ;
			currentPos++;
			
		}
		return TRUE;
	}
	void SetOrigionalDirectory()
	{
		SetCurrentDirectory(lpBuffer);
	}
	
	
	void SetDirectory(CString sBaseURL,CString sProjectName)
	{
		m_sProjectName = sProjectName;
				
		GetCurrentDirectory(255,lpBuffer);
		m_sAppDir = lpBuffer;
		CString empty = "";
		
		if(GetFileAttributes("MySites") != FILE_ATTRIBUTE_DIRECTORY) 
		{
			CreateDirectory("MySites",NULL); 						
		}
		m_sLogFileName =empty + lpBuffer + "\\" +"MySites\\" +  sProjectName +"\\" +  m_sLogFileName;
		m_sListFileName =empty + lpBuffer + "\\" +"MySites\\" +  sProjectName +"\\" + m_sListFileName;
		
		m_sBaseURL = empty + lpBuffer + "\\" +"MySites\\" +  sProjectName +"\\" ;
		m_sBaseURL.Replace('/','\\');		
		
		m_sListFileName.Replace('/','\\');
		m_sLogFileName.Replace('/','\\');
		
		//CString sBaseDir = empty + "MySites\\" + sProjectName + "\\ 
		//CreateDirectory(empty +"MySites\\" + sProjectName,NULL);
		
		CreateAllDirectories(m_sLogFileName);
		
		
		sBaseURL.Replace('\\','/');
		
		
		DWORD dwServiceType=0;
		CString strServer;
		CString strObject;
		INTERNET_PORT nPort;
		if(!AfxParseURL(sBaseURL,dwServiceType,strServer,strObject,nPort ) )
		{
			//Try sticking "http://" before it
			sBaseURL = _T("http://") + sBaseURL;
			AfxParseURL(sBaseURL,dwServiceType,strServer,strObject,nPort );
		}
		
		CString sBaseDir; 
		if(strServer.IsEmpty() == FALSE)
		{
			if( strServer.GetAt(strServer.GetLength() - 1) != '/' || strServer.GetAt(strServer.GetLength() - 1) != '\\' )
				
				sBaseDir = empty +"MySites\\" + sProjectName + "\\" + strServer + "\\";
			
			else
				
				sBaseDir = empty +"MySites\\" + sProjectName + "\\" + strServer ;
		}
		sBaseDir.Replace('\\','/');
		CreateAllDirectories(sBaseDir);	
		
		if(SetCurrentDirectory(sBaseDir) == 0 )
		{
			LPVOID lpMsgBuf;
			FormatMessage( 
				FORMAT_MESSAGE_ALLOCATE_BUFFER | 
				FORMAT_MESSAGE_FROM_SYSTEM | 
				FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL,
				GetLastError(),
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf,
				0,
				NULL 
				);
			// Process any inserts in lpMsgBuf.
			// ...
			// Display the string.
			MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );
			// Free the buffer.
			LocalFree( lpMsgBuf );
		}
		
	}	
};





